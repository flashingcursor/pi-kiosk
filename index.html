<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pi Media Hub</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      background: #000;
      color:#fff;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      overflow:hidden;
      height:100vh;
      position:relative;
      display:flex;
      justify-content:center;
      align-items:center;
      cursor: none;
    }
    body.show-cursor { cursor: default; }
    canvas { position:absolute; top:0; left:0; width:100%; height:100%; z-index:-2; }
    canvas.low-perf { display: none; }
    .container {
      display:flex;
      flex-direction:column;
      gap:32px;
      width:90vw;
      max-width:720px;
      z-index:2;
    }
    .item {
      display:flex;
      align-items:center;
      justify-content:center;
      gap:28px;
      font-size:2.9rem;
      font-weight:600;
      cursor:pointer;
      transition:all 0.3s ease;
      opacity:0.30;
      padding:20px 0;
    }
    .item img {
      height:62px;
      width:auto;
      transition:opacity 0.3s ease;
      filter: brightness(1.3);
    }
    .item:hover, .item:focus {
      opacity:1.00;
      outline:none;
    }
    .item.selected {
      opacity:1.00;
    }

    /* Exit Button - Bottom Right */
    #exitBtn {
      position:absolute;
      bottom:40px;
      right:40px;
      display:flex;
      align-items:center;
      gap:12px;
      font-size:1.8rem;
      font-weight:600;
      padding:16px 24px;
      background:rgba(255, 50, 50, 0.2);
      border:2px solid #ff4444;
      border-radius:16px;
      cursor:pointer;
      transition:all 0.3s ease;
      opacity:0.4;
      z-index:3;
    }
    #exitBtn:hover, #exitBtn:focus {
      opacity:1;
      background:rgba(255, 50, 50, 0.4);
      transform:scale(1.05);
      outline:none;
    }
    #exitBtn svg {
      width:32px; height:32px; fill:#ff4444;
    }

    /* Confirmation Dialog */
    #confirmDialog {
      position:absolute;
      top:50%; left:50%;
      transform:translate(-50%, -50%);
      background:rgba(15,15,25,0.98);
      border:3px solid #00aaff;
      border-radius:24px;
      padding:40px 60px;
      text-align:center;
      z-index:5;
      opacity:0;
      pointer-events:none;
      transition:opacity 0.4s ease, transform 0.4s ease;
      box-shadow:0 0 60px rgba(0,170,255,0.6);
      backdrop-filter:blur(12px);
      width:80vw;
      max-width:600px;
    }
    #confirmDialog.active {
      opacity:1;
      pointer-events:all;
      transform:translate(-50%, -50%) scale(1.05);
    }
    #dialogLogo {
      width:120px;
      height:120px;
      margin-bottom:20px;
      filter:drop-shadow(0 0 20px #00aaff);
      object-fit: contain;
    }
    #dialogDesc {
      font-size:1.6rem;
      margin-bottom:30px;
      opacity:0.9;
    }
    #confirmDialog .btns {
      display:flex;
      justify-content:center;
      gap:30px;
    }
    #confirmDialog .btn {
      padding:14px 36px;
      font-size:1.5rem;
      font-weight:600;
      border-radius:16px;
      cursor:pointer;
      transition:all 0.3s ease;
    }
    #confirmDialog .btn.confirm {
      background:#00ff88;
      color:#000;
      border:2px solid #00ff88;
    }
    #confirmDialog .btn.cancel {
      background:transparent;
      color:#ff6666;
      border:2px solid #ff6666;
    }
    #confirmDialog .btn:hover {
      transform:scale(1.1);
    }

    /* White Flash */
    #whiteFlash {
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      background:#fff;
      opacity:0;
      z-index:6;
      pointer-events:none;
      transition: opacity 0.8s ease-out;
    }

    /* Transparent logo overlay (5% opacity, colored) */
    .overlay {
      position:absolute;
      top:50%; left:50%;
      transform:translate(-50%,-50%);
      width:72vw;
      max-width:960px;
      opacity:0;
      pointer-events:none;
      transition:opacity 0.4s ease;
      z-index:-1;
    }
    .overlay img {
      width:100%;
      object-fit: contain;
    }
    .overlay.active { opacity:0.05; }

    /* Offline Overlay */
    #offlineScreen {
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      background:rgba(0,0,0,0.92);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      z-index:10;
      opacity:0;
      pointer-events:none;
      transition:opacity 0.6s ease;
      text-align:center;
      padding:40px;
      font-size:2.2rem;
      line-height:1.6;
    }
    #offlineScreen.active {
      opacity:1;
      pointer-events:all;
    }
    #offlineScreen h1 {
      font-size:4rem;
      margin-bottom:20px;
      color:#ff4444;
    }
    #offlineScreen p {
      max-width:800px;
      opacity:0.9;
      margin-bottom: 10px;
    }

    /* Loading Indicator */
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      opacity: 0.7;
      z-index: 1;
    }
    #loading.hidden { display: none; }
  </style>
</head>
<body>
  <canvas id="orbCanvas"></canvas>
  <div id="whiteFlash"></div>
  <div id="loading">Loading...</div>

  <!-- Offline Screen -->
  <div id="offlineScreen">
    <h1>Network Offline</h1>
    <p>The media hub requires an internet connection to stream content.</p>
    <p>Please check your WiFi or Ethernet connection and try again.</p>
  </div>

  <!-- Confirmation Dialog -->
  <div id="confirmDialog">
    <img id="dialogLogo" src="" alt="">
    <p id="dialogDesc">This will open in full screen.</p>
    <div class="btns">
      <div class="btn confirm" tabindex="1">Confirm</div>
      <div class="btn cancel" tabindex="2">Cancel</div>
    </div>
  </div>

  <!-- Overlays (populated dynamically) -->
  <div id="overlays"></div>

  <!-- Main Menu (populated dynamically) -->
  <div class="container" id="appContainer"></div>

  <!-- Exit Button -->
  <div id="exitBtn" tabindex="999">
    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
    Exit
  </div>

  <script>
    // === CONFIGURATION ===
    let config = null;
    let apps = [];

    // === STATE ===
    let isOnline = true;
    let currentSelection = 0;
    let inConfirm = false;
    let pendingApp = null;
    let cursorTimeout = null;

    // === ELEMENTS ===
    const appContainer = document.getElementById('appContainer');
    const overlaysContainer = document.getElementById('overlays');
    const exitBtn = document.getElementById('exitBtn');
    const confirmDialog = document.getElementById('confirmDialog');
    const dialogLogo = document.getElementById('dialogLogo');
    const dialogDesc = document.getElementById('dialogDesc');
    const confirmBtn = document.querySelector('#confirmDialog .confirm');
    const cancelBtn = document.querySelector('#confirmDialog .cancel');
    const whiteFlash = document.getElementById('whiteFlash');
    const offlineScreen = document.getElementById('offlineScreen');
    const loading = document.getElementById('loading');
    const canvas = document.getElementById('orbCanvas');

    // === LOAD CONFIG ===
    async function loadConfig() {
      try {
        const response = await fetch('config.json');
        if (!response.ok) {
          const defaultResponse = await fetch('config.default.json');
          config = await defaultResponse.json();
        } else {
          config = await response.json();
        }
        return config;
      } catch (error) {
        console.error('Failed to load config:', error);
        // Fallback minimal config
        config = {
          apps: {},
          display: { performance_mode: 'balanced', hide_cursor_timeout: 3000 },
          startup: { check_network: true },
          exit: { action: 'cec_standby', show_confirmation: true }
        };
        return config;
      }
    }

    // === INITIALIZE UI ===
    function initializeUI() {
      // Build app list from config
      apps = Object.entries(config.apps)
        .filter(([key, app]) => app.enabled)
        .map(([key, app]) => ({ key, ...app }));

      // Populate apps
      apps.forEach((app, index) => {
        const item = document.createElement('div');
        item.className = 'item';
        item.tabIndex = index + 1;
        item.dataset.app = app.key;
        item.innerHTML = `
          <img src="${app.icon}" alt="${app.name}">
          ${app.name}
        `;
        appContainer.appendChild(item);

        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = `overlay ${app.key}`;
        overlay.innerHTML = `<img src="${app.icon}" alt="${app.name}">`;
        overlaysContainer.appendChild(overlay);
      });

      loading.classList.add('hidden');

      // Setup cursor hiding
      if (config.display.hide_cursor_timeout > 0) {
        document.body.classList.add('show-cursor');
        resetCursorTimeout();
      }

      // Initialize selection
      updateSelection(0);
      focusItem(0);
    }

    // === CURSOR MANAGEMENT ===
    function resetCursorTimeout() {
      document.body.classList.add('show-cursor');
      if (cursorTimeout) clearTimeout(cursorTimeout);
      if (config.display.hide_cursor_timeout > 0) {
        cursorTimeout = setTimeout(() => {
          document.body.classList.remove('show-cursor');
        }, config.display.hide_cursor_timeout);
      }
    }

    document.addEventListener('mousemove', resetCursorTimeout);
    document.addEventListener('keydown', resetCursorTimeout);

    // === NETWORK CHECK ===
    async function checkNetwork() {
      if (!config.startup.check_network) return true;

      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 3000);

        const response = await fetch('https://www.google.com/favicon.ico?' + Date.now(), {
          mode: 'no-cors',
          signal: controller.signal
        });

        clearTimeout(timeout);
        return true;
      } catch {
        return false;
      }
    }

    async function updateNetworkStatus() {
      const online = await checkNetwork();
      if (online !== isOnline) {
        isOnline = online;
        offlineScreen.classList.toggle('active', !isOnline);
      }
    }

    // === SELECTION MANAGEMENT ===
    function updateSelection(index) {
      const items = document.querySelectorAll('.item');
      const overlays = document.querySelectorAll('.overlay');

      items.forEach(i => i.classList.remove('selected'));
      overlays.forEach(o => o.classList.remove('active'));
      exitBtn.classList.remove('selected');

      if (index < items.length) {
        items[index].classList.add('selected');
        const app = apps[index];
        const overlay = document.querySelector(`.overlay.${app.key}`);
        if (overlay) overlay.classList.add('active');
      } else {
        exitBtn.classList.add('selected');
      }
    }

    function focusItem(index) {
      const items = document.querySelectorAll('.item');
      if (index < items.length) {
        items[index].focus();
      } else {
        exitBtn.focus();
      }
    }

    // === LAUNCH APP ===
    function launchApp(appKey) {
      const app = apps.find(a => a.key === appKey);
      if (!app) return;

      whiteFlash.style.opacity = '1';

      setTimeout(() => {
        // Call Python launcher via special protocol or window.location
        window.location.href = `launch://app/${appKey}`;
      }, 300);
    }

    // === CONFIRM DIALOG ===
    function showConfirm(appKey) {
      const app = apps.find(a => a.key === appKey);
      if (!app) return;

      inConfirm = true;
      pendingApp = appKey;
      dialogLogo.src = app.icon;
      dialogDesc.textContent = 'This will open in full screen.';
      confirmDialog.classList.add('active');
      confirmBtn.focus();
    }

    function hideConfirm() {
      inConfirm = false;
      pendingApp = null;
      confirmDialog.classList.remove('active');
    }

    function launchConfirmed() {
      hideConfirm();
      launchApp(pendingApp);
    }

    confirmBtn.onclick = launchConfirmed;
    cancelBtn.onclick = hideConfirm;

    // === EXIT HANDLING ===
    function handleExit() {
      if (config.exit.show_confirmation) {
        if (confirm('Exit Pi Media Hub?')) {
          performExit();
        }
      } else {
        performExit();
      }
    }

    function performExit() {
      // Signal to Python backend
      window.location.href = 'launch://exit';
    }

    exitBtn.onclick = handleExit;

    // === NAVIGATION ===
    document.addEventListener('keydown', (e) => {
      if (!isOnline && !['~', 'Escape'].includes(e.key)) return;

      // Debug: Toggle offline mode with ~
      if (e.key === '~') {
        isOnline = !isOnline;
        offlineScreen.classList.toggle('active', !isOnline);
        e.preventDefault();
        return;
      }

      if (inConfirm) {
        if (e.key === 'Escape' || e.key === 'Backspace') {
          hideConfirm();
          e.preventDefault();
          return;
        }
        if (e.key === 'Enter') {
          if (document.activeElement === confirmBtn) {
            launchConfirmed();
          } else {
            hideConfirm();
          }
          e.preventDefault();
          return;
        }
        if (e.key === 'ArrowRight' || e.key === 'ArrowLeft' || e.key === 'Tab') {
          if (document.activeElement === confirmBtn) {
            cancelBtn.focus();
          } else {
            confirmBtn.focus();
          }
          e.preventDefault();
          return;
        }
        return;
      }

      const totalItems = apps.length;
      const isInExit = currentSelection === totalItems;

      if (e.key === 'ArrowDown') {
        if (isInExit) {
          currentSelection = 0;
        } else {
          currentSelection = (currentSelection + 1) % totalItems;
        }
        updateSelection(currentSelection);
        focusItem(currentSelection);
        e.preventDefault();
      } else if (e.key === 'ArrowUp') {
        if (isInExit) {
          currentSelection = totalItems - 1;
        } else {
          currentSelection = (currentSelection - 1 + totalItems) % totalItems;
        }
        updateSelection(currentSelection);
        focusItem(currentSelection);
        e.preventDefault();
      } else if (e.key === 'ArrowRight' && !isInExit) {
        currentSelection = totalItems;
        updateSelection(currentSelection);
        focusItem(currentSelection);
        e.preventDefault();
      } else if (e.key === 'ArrowLeft' && isInExit) {
        currentSelection = totalItems - 1;
        updateSelection(currentSelection);
        focusItem(currentSelection);
        e.preventDefault();
      } else if (e.key === 'Enter') {
        if (currentSelection < totalItems) {
          const app = apps[currentSelection];
          showConfirm(app.key);
        } else {
          handleExit();
        }
        e.preventDefault();
      }
    });

    // Mouse hover
    document.addEventListener('mouseover', (e) => {
      if (inConfirm) return;

      const item = e.target.closest('.item');
      if (item) {
        const items = Array.from(document.querySelectorAll('.item'));
        const index = items.indexOf(item);
        if (index >= 0) {
          currentSelection = index;
          updateSelection(currentSelection);
        }
      } else if (e.target.closest('#exitBtn')) {
        currentSelection = apps.length;
        updateSelection(currentSelection);
      }
    });

    // === ORB ANIMATION ===
    function initOrbs() {
      const ctx = canvas.getContext('2d', { alpha: true });
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const perfMode = config.display.performance_mode || 'balanced';

      // Adjust orb count based on performance mode
      const orbCounts = { low: 3, balanced: 5, high: 8 };
      const orbCount = orbCounts[perfMode] || 5;

      const orbs = [];
      const baseColors = [
        'rgba(255, 0, 0, 0.04)',
        'rgba(30, 215, 96, 0.04)',
        'rgba(138, 43, 226, 0.04)'
      ];

      class Orb {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.radius = 100 + Math.random() * 150;
          this.speed = 0.2 + Math.random() * 0.4;
          this.angle = Math.random() * Math.PI * 2;
          this.color = baseColors[Math.floor(Math.random() * baseColors.length)];
        }
        update() {
          this.angle += 0.003;
          this.x += Math.cos(this.angle) * this.speed;
          this.y += Math.sin(this.angle) * this.speed;

          if (this.x > canvas.width + this.radius) this.x = -this.radius;
          if (this.x < -this.radius) this.x = canvas.width + this.radius;
          if (this.y > canvas.height + this.radius) this.y = -this.radius;
          if (this.y < -this.radius) this.y = canvas.height + this.radius;
        }
        draw() {
          const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
          gradient.addColorStop(0, this.color.replace('0.04', '0.06'));
          gradient.addColorStop(1, this.color.replace('0.04', '0.00'));
          ctx.fillStyle = gradient;
          ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
        }
      }

      for (let i = 0; i < orbCount; i++) {
        orbs.push(new Orb());
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        orbs.forEach(orb => {
          orb.update();
          orb.draw();
        });
        requestAnimationFrame(animate);
      }

      // Don't animate if performance mode is 'low'
      if (perfMode !== 'low') {
        animate();
      }

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    }

    // === STARTUP ===
    async function startup() {
      await loadConfig();
      initializeUI();
      initOrbs();

      if (config.startup.check_network) {
        await updateNetworkStatus();
        setInterval(updateNetworkStatus, 5000);
      }
    }

    startup();
  </script>
</body>
</html>
